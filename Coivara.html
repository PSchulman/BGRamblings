<!DOCTYPE html>  
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Coivara – by Pablo Schulman</title>
<style>
  body { font-family: sans-serif; text-align: center; }
  h1 { margin-bottom: 0; }
  h2.subtitle {
    font-size: 1.2em;
    font-weight: normal;
    margin-top: -10px;
    color: #555;
  }
  .circle { 
    position: absolute; width: 50px; height: 50px; 
    border-radius: 50%; border: 2px solid black; 
    display: flex; align-items: center; justify-content: center; 
    cursor: pointer; background-color: lightgray; 
    transition: all 0.2s ease;
  }
  .pawn { background-color: yellow !important; }
  .highlight { border: 2px solid red; background-color: lightblue; }
</style>
</head>
<body>

<h1>Coivara</h1>
<h2 class="subtitle">by Pablo Schulman</h2>

<div id="menu">
  Mode: 
  <select id="modeSelect">
    <option value="human">Human vs Bot</option>
    <option value="bot">Bot vs Human</option>
    <option value="botbot">Bot vs Bot</option>
  </select>
  <br><br>
  Board size: 
  <select id="boardSize">
    <option value="9">9 fields </option>
    <option value="11" selected>11 fields </option>
    <option value="13">13 fields</option>
  </select>
  <br><br>
  Seeds per field:
  <select id="seedCount">
    <option value="3" selected>3</option>
    <option value="4">4</option>
    <option value="5">5</option>
  </select>
  <br><br>
  <button onclick="startGame()">Start</button>
  <button onclick="resetGame()">Reset</button>
  <button onclick="showRules()">Rules</button>
</div>

<div id="simulation" style="display:none; margin-top:20px;">
  <h3>Simulation - Bot vs Bot</h3>
  Number of matches: <input type="number" id="simCount" value="10" min="1">
  <button onclick="startSimulation()">Start Simulation</button>
  <div id="simProgress" style="margin-top:10px;"></div>
  <div id="simResults" style="margin-top:10px; text-align:left; max-width:400px; margin:auto;"></div>
</div>

<div id="rules" style="display:none;">
  <h2>Rules</h2>
  <ul style="text-align:left; max-width:400px; margin:auto;">
    <li>The board is made of 9, 11 or 13 fields, each containing 3, 4 or 5 seeds at the beginning of the game.</li>
    <li>An external pawn is always aligned to a field. In the app, the pawn is represented by highlighting a field in yellow.</li>
    <li>On your turn, first check if you have any valid move (a valid move is the pawn field or an adjacent field with seeds).</li>
    <li>If there are no valid moves, the fields adjacent to the pawn are removed until at least one valid move exists.</li>
    <li>Once a valid move is chosen, you sow, one at a time, one seed per field starting on the next field after the selected one.</li>
    <li>The sowing direction depends on the chosen house:
      <ul>
        <li>Left of the pawn → counter-clockwise</li>
        <li>Right of the pawn → clockwise</li>
        <li>Pawn field → choose clockwise or counter-clockwise.</li>
      </ul>
    </li>
    <li>If the last seed falls in an empty field, it is harvested and set aside next to you.</li>
    <li>The turn passes to the other player regardless of harvest or not.</li>
    <li>The game ends when there are no seeds left. </li>
    <li>The player with the most harvested seeds wins.</li>
  </ul>
  <button onclick="hideRules()">Back</button>
</div>

<div id="board" style="position:relative; width:400px; height:400px; margin:20px auto;"></div>
<div id="score"></div>
<div id="winner"></div>

<script>
// ------------------------------ Variáveis Globais ------------------------------
let initialSeeds = 3;
let circles = [];
let pawn = 0;
let turn = 1;
let score = {1:0,2:0};
let gameStarted = false;
let mode = 'human';
let humanPlayer = 1;
let boardLength = 11;

// ------------------------------ Utilidades ------------------------------
function validChoices(pawnPos, board = circles) {
  if(board.length === 0) return [];
  const n = board.length;
  const indices = [(pawnPos-1+n)%n, pawnPos, (pawnPos+1)%n];
  return indices.filter(i => board[i] > 0);
}

function removeAdjacentIfBlocked() {
  let changed = true;
  while(changed && circles.length >= 3) {
    changed = false;
    const n = circles.length;
    const left = (pawn-1+n)%n;
    const right = (pawn+1)%n;
    if(circles[pawn]===0 && circles[left]===0 && circles[right]===0) {
      const hi = Math.max(left,right);
      const lo = Math.min(left,right);
      circles.splice(hi,1);
      circles.splice(lo,1);
      if(pawn > hi) pawn -= 2;
      else if(pawn > lo) pawn -= 1;
      pawn = Math.max(0, Math.min(pawn, circles.length-1));
      changed = true;
    }
  }
}

function removeAdjacentIfBlocked_sim(board, pawnPos) {
  let changed = true;
  board = board.slice();
  while(changed && board.length >= 3) {
    changed = false;
    const n = board.length;
    const left = (pawnPos-1+n)%n;
    const right = (pawnPos+1)%n;
    if(board[pawnPos]===0 && board[left]===0 && board[right]===0) {
      const hi = Math.max(left,right);
      const lo = Math.min(left,right);
      board.splice(hi,1);
      board.splice(lo,1);
      if(pawnPos > hi) pawnPos -= 2;
      else if(pawnPos > lo) pawnPos -= 1;
      pawnPos = Math.max(0, Math.min(pawnPos, board.length-1));
      changed = true;
    }
  }
  return {board, pawnPos};
}

function calculateFinal(index, direction) {
  let pos = index;
  let seeds = circles[index];
  const n = circles.length;
  while(seeds>0) {
    pos = (pos + direction + n) % n;
    seeds--;
  }
  return pos;
}

// ------------------------------ Jogada Normal ------------------------------
function makeMove(index, direction) {
  if(!validChoices(pawn).includes(index)) return;
  let n = circles.length;
  let seeds = circles[index];
  circles[index] = 0;
  let pos = index;
  while(seeds > 0) {
    pos = (pos + direction + n) % n;
    circles[pos] += 1;
    seeds--;
  }
  if(circles[pos] === 1) { score[turn] += 1; circles[pos] = 0; }
  pawn = pos;
  removeAdjacentIfBlocked();
  turn = turn === 1 ? 2 : 1;
  removeHighlights();
  render();
  if(gameStarted && turn !== humanPlayer) setTimeout(botMove, 10);
}

// ------------------------------ BOT ------------------------------
function simulateMove(board, pawnPos, index, direction) {
  let newBoard = board.slice();
  let seeds = newBoard[index];
  newBoard[index] = 0;
  let pos = index;
  const n = newBoard.length;
  while(seeds>0){
    pos = (pos+direction+n)%n;
    newBoard[pos]+=1;
    seeds--;
  }
  let captured=0;
  if(newBoard[pos]===1){ captured=1; newBoard[pos]=0; }
  pawnPos=pos;
  let result = removeAdjacentIfBlocked_sim(newBoard,pawnPos);
  return {board:result.board,pawn:result.pawnPos,captured};
}

function botMove(){
  if(!gameStarted) return;
  let choices = validChoices(pawn);
  if(choices.length===0){ 
    removeAdjacentIfBlocked(); 
    render(); 
    return; 
  }

  let bestMoves = [];
  let maxCap = -1;

  for(let idx of choices){
    let dirs=[];
    if(idx===(pawn-1+circles.length)%circles.length) dirs=[-1];
    else if(idx===(pawn+1)%circles.length) dirs=[1];
    else dirs=[-1,1];

    for(let dir of dirs){
      let sim = simulateMove(circles,pawn,idx,dir);
      if(sim.captured > maxCap){
        maxCap = sim.captured;
        bestMoves = [{idx, dir}];
      } else if(sim.captured === maxCap){
        bestMoves.push({idx, dir});
      }
    }
  }

  if(bestMoves.length > 0){
    const move = bestMoves[Math.floor(Math.random() * bestMoves.length)];
    makeMove(move.idx, move.dir);
  }
}

// ------------------------------ UI / Fluxo ------------------------------
function removeHighlights(){ 
  document.querySelectorAll('.circle').forEach(el=>el.classList.remove('highlight')); 
}

function showFinalOptions(index){
  removeHighlights();
  const n = circles.length;
  let dirs=[];
  if(index===(pawn-1+n)%n) dirs=[-1];
  else if(index===(pawn+1)%n) dirs=[1];
  else dirs=[-1,1];
  for(let dir of dirs){
    let final=calculateFinal(index,dir);
    let el=document.getElementsByClassName('circle')[final];
    el.classList.add('highlight');
    el.onclick=()=>makeMove(index,dir);
  }
}

document.getElementById('modeSelect').addEventListener('change', function(){
  if(this.value==='botbot'){
    document.getElementById('simulation').style.display='block';
  } else {
    document.getElementById('simulation').style.display='none';
  }
});

function startGame() {
  boardLength = parseInt(document.getElementById('boardSize').value);
  initialSeeds = parseInt(document.getElementById('seedCount').value);
  circles = Array(boardLength).fill(initialSeeds);
  pawn = 0;
  score = {1:0,2:0};
  mode = document.getElementById('modeSelect').value;
  gameStarted = true;
  if(mode==='human'){ humanPlayer=1; turn=1; }
  else if(mode==='bot'){ humanPlayer=1; turn=2; setTimeout(botMove,10); }
  else if(mode==='botbot'){ humanPlayer=0; turn=1; setTimeout(botMove,10); }
  render();
}

function resetGame(){ location.reload(); }

function showRules(){ document.getElementById('menu').style.display='none'; document.getElementById('rules').style.display='block'; }
function hideRules(){ document.getElementById('rules').style.display='none'; document.getElementById('menu').style.display='block'; }

function render() {
  const boardDiv = document.getElementById('board');
  boardDiv.innerHTML='';
  const n = circles.length;
  const radius = Math.min(boardDiv.clientWidth, boardDiv.clientHeight)/2 - 40; 
  for(let i=0;i<n;i++){
    const angle=(2*Math.PI/n)*i;
    const x=boardDiv.clientWidth/2+radius*Math.cos(angle)-25;
    const y=boardDiv.clientHeight/2+radius*Math.sin(angle)-25;
    const div = document.createElement('div');
    div.className='circle'+(i===pawn?' pawn':'');
    div.style.left=x+'px'; div.style.top=y+'px';
    div.innerText=circles[i];
    div.onclick = ()=>{ 
      if(!gameStarted||turn!==humanPlayer) return; 
      if(validChoices(pawn).includes(i)) showFinalOptions(i); 
    };
    boardDiv.appendChild(div);
  }
  document.getElementById('score').innerText=`Player 1: ${score[1]} | Player 2: ${score[2]}`;
  if(circles.every(c=>c===0)){
    let winner='';
    if(score[1]>score[2]) winner='Player 1 wins 🎉';
    else if(score[2]>score[1]) winner='Player 2 wins 🎉';
    else winner='Tie ⚖️';
    document.getElementById('winner').innerText=winner;
  }
}

// ------------------------------ SIMULAÇÃO BOT vs BOT ------------------------------
async function startSimulation(){
  const n = parseInt(document.getElementById('simCount').value);
  const metrics = { player1: [], player2: [], moves: [] };
  const wins = { player1: 0, player2: 0, draws: 0 };
  const progressDiv = document.getElementById('simProgress');
  const resultsDiv = document.getElementById('simResults');
  resultsDiv.innerHTML='';

  for(let i=0;i<n;i++){
    // Inicializa jogo
    boardLength = parseInt(document.getElementById('boardSize').value);
    initialSeeds = parseInt(document.getElementById('seedCount').value);
    circles = Array(boardLength).fill(initialSeeds);
    pawn = 0;
    score = {1:0,2:0};
    turn = 1;
    gameStarted = true;
    let moveCount = 0;

    while(circles.some(c=>c>0)){
      botMove();
      moveCount++;
      await new Promise(r=>setTimeout(r,0));
    }

    metrics.player1.push(score[1]);
    metrics.player2.push(score[2]);
    metrics.moves.push(moveCount);

    if(score[1] > score[2]) wins.player1++;
    else if(score[2] > score[1]) wins.player2++;
    else wins.draws++; // contabiliza empate

    progressDiv.innerText = `Simulação: ${i+1} / ${n}`;
  }

  function stats(arr){ 
    const sum = arr.reduce((a,b)=>a+b,0);
    return {min: Math.min(...arr), max: Math.max(...arr), mean: (sum/arr.length).toFixed(2)};
  }

  const p1 = stats(metrics.player1);
  const p2 = stats(metrics.player2);
  const moves = stats(metrics.moves);

  resultsDiv.innerHTML = `
    <b>Player 1 (harvests):</b> min: ${p1.min}, mean: ${p1.mean}, max: ${p1.max}<br>
    <b>Player 2 (harvests):</b> min: ${p2.min}, mean: ${p2.mean}, max: ${p2.max}<br>
    <b>Moves per match:</b> min: ${moves.min}, mean: ${moves.mean}, max: ${moves.max}<br>
    <b>Simulated matches:</b> ${n}<br>
    <b>Player 1 wins:</b> ${wins.player1}<br>
    <b>Player 2 wins:</b> ${wins.player2}<br>
    <b>Ties:</b> ${wins.draws}
  `;
}
</script>

</body>
</html>
